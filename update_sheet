
/**
 * Updates the "Main" sheet with portfolio summary, positions, and combined OCO orders.
 */
function updateSheet() {
  initializeCredentials();
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = ss.getSheetByName("Main");
  if (!sheet) return;

  // 1. Update Account Summary
  var accountInfo = getAccount();
  if (accountInfo) {
    sheet.getRange("B6").setValue(accountInfo.buying_power || 0).setNumberFormat("$#,##0.00");
    sheet.getRange("B7").setValue(accountInfo.cash || 0).setNumberFormat("$#,##0.00");
    sheet.getRange("B8").setValue(accountInfo.portfolio_value || 0).setNumberFormat("$#,##0.00");
  }

  // 2. Define Headers - Changed "Sell Limit" and "Stop" to "Take Profit" and "Limit"
  var headers = [
    "Ticker", "Owned Qty", "Cost Basis", "Unrealized Gain", "Profit %", 
    "Cost Basis/Share", "Current Price", "% of Portfolio", 
    "Buy Qty", "Buy Limit", 
    "Sell Qty", "Take Profit", "Limit", "Order ID"
  ];
  sheet.getRange(13, 1, 1, headers.length).setValues([headers]).setFontWeight("bold").setBackground("#f3f3f3");

  // 3. Process Positions and Orders
  var positions = listPositions();
  var allOrders = listOrders();
  var openOrders = allOrders.filter(o => ['new', 'partially_filled', 'pending_cancel', 'accepted'].indexOf(o.status) !== -1);
  var portfolioValue = parseFloat(accountInfo.portfolio_value) || 1;

  var masterMap = {};
  positions.forEach(p => { masterMap[p.symbol] = { pos: p, buys: [], sells: [] }; });
  
  // Grouping logic: Pair OCO legs together
  openOrders.forEach(o => {
    if (!masterMap[o.symbol]) masterMap[o.symbol] = { pos: null, buys: [], sells: [] };
    if (o.side === 'buy') {
      masterMap[o.symbol].buys.push(o);
    } else {
      // Check if this is a leg of an OCO already in the list
      var added = false;
      masterMap[o.symbol].sells.forEach(s => {
        if (s.order_class === 'oco' || s.order_class === 'bracket') {
          // If they share a quantity and side, they are likely related legs
          s.legs = s.legs || [];
          s.legs.push(o);
          added = true;
        }
      });
      if (!added) masterMap[o.symbol].sells.push(o);
    }
  });

  var symbols = Object.keys(masterMap).sort();
  var outputRows = [];

  symbols.forEach(sym => {
    var data = masterMap[sym];
    var p = data.pos;
    var rowCount = Math.max(1, data.buys.length, data.sells.length);

    for (var i = 0; i < rowCount; i++) {
      var buy = data.buys[i] || {};
      var sell = data.sells[i] || {};
      
      var tpPrice = sell.limit_price || "";
      var slLimitPrice = "";
      
      // Parse legs for Take Profit and Stop Limit
      var legs = (sell.legs || []);
      legs.forEach(leg => {
        if (leg.type === 'limit' || leg.order_type === 'limit') tpPrice = leg.limit_price;
        if (leg.type === 'stop_limit' || leg.order_type === 'stop_limit') slLimitPrice = leg.limit_price;
        // Fallback for simple stop orders if you want to see the trigger
        if (!slLimitPrice && (leg.type === 'stop' || leg.order_type === 'stop')) slLimitPrice = leg.stop_price;
      });

      var row = [
        sym,
        (i === 0 && p) ? p.qty : "",
        (i === 0 && p) ? p.market_value : "",
        (i === 0 && p) ? p.unrealized_pl : "",
        (i === 0 && p) ? p.unrealized_plpc : "",
        (i === 0 && p) ? (p.cost_basis / p.qty) : "",
        (i === 0 && p) ? p.current_price : "",
        (i === 0 && p) ? (p.market_value / portfolioValue) : "",
        buy.qty || "",
        buy.limit_price || "",
        sell.qty || "",
        tpPrice,
        slLimitPrice,
        buy.id || sell.id || ""
      ];
      outputRows.push(row);
    }
  });

  // 4. Write Data
  sheet.getRange(14, 1, 500, headers.length).clearContent();
  if (outputRows.length > 0) {
    sheet.getRange(14, 1, outputRows.length, headers.length).setValues(outputRows);
    sheet.getRange(14, 5, outputRows.length, 1).setNumberFormat("0.00%");
    sheet.getRange(14, 12, outputRows.length, 2).setNumberFormat("$#,##0.00");
  }
}
